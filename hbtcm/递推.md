# 骨牌铺方格（简单的推断题 HDU2046）
假设用arr[i]表示2\*i的方格一共有组成的方法数，我们知道arr[1]=1;arr[2]=2;
现在假设我们已经知道了arr[i-1]和arr[i-2],求arr[i],所谓arr[i],不过是在2\*（i-1）的格子后边加上一格2\*1的方格罢了，
骨牌在这一格上横着放，竖着放，如果前面i-1块已经铺好，则第i块只有一种铺法，就是竖着放，如果要横着放，也只有一种铺法，
不过要求前面i-2块已经铺好！
因此arr[i]=arr[i-1]+arr[i-2];
```
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
	long long a[51];
	int b,i;
	a[1]=1;
	a[2]=2;
	for(i = 3; i < 51; i++)
		a[i] = a[i-1] + a[i-2];
	while(cin>>b){
		cout<<a[b]<<endl;
	}
    return 0;
}
```

# 分割平面
## (1) n条直线最多分平面问题
题目大致如:n条直线，最多可以把平面分为多少个区域。
析:可能你以前就见过这题目，这充其量是一道初中的思考题。
但一个类型的题目还是从简单的入手，才容易发现规律。当有n-1条直线时，
平面最多被分成了f（n-1）个区域。则第n条直线要是切成的区域数最多，
就必须与每条直线相交且不能有同一交点。这样就会得到n-1个交点。
这些交点将第n条直线分为2条射线和n-2条线断。而每条射线和线断将以
有的区域一分为二。这样就多出了2+（n-2）个区域。
```
        故：f(n)=f(n-1)+n=f(n-2)+(n-1)+n
                      ……
                         =f(1)+1+2+……+n
                         =n(n+1)/2+1
```
## (2) 折线分平面（hdu2050）
根据直线分平面可知，由交点决定了射线和线段的条数，进而决定了新增的区域数。
当n-1条折线时，区域数为f（n-1）。为了使增加的区域最多，则折线的两边的线段
要和n-1条折线的边，即2*（n-1）条线段相交。那么新增的线段数为4*（n-1），
射线数为2。但要注意的是，折线本身相邻的两线段只能增加一个区域。
```
       故：f(n)=f(n-1)+4(n-1)+2-1=f(n-1)+4(n-1)+1
                                 =f(n-2)+4(n-2)+4(n-1)+2
                                   ……
                                 =f(1)+4+4*2+……+4(n-1)+(n-1)   
                                 =2n^2-n+1
```
## (3) 封闭曲线分平面问题
题目大致如设有n条封闭曲线画在平面上，而任何两条封闭曲线恰好相交于两点，
且任何三条封闭曲线不相交于同一点，问这些封闭曲线把平面分割成的区域个数。
析：当n-1个圆时，区域数为f(n-1).那么第n个圆就必须与前n-1个圆相交，
则第n个圆被分为2（n-1）段线段，增加了2（n-1）个区域。
```
        故： f(n)=f(n-1)+2(n-1)=f(1)+2+4+……+2(n-1)
                               =n^2-n+2
```
## (4)平面分割空间问题（hdu1290）
由二维的分割问题可知，平面分割与线之间的交点有关，即交点决定射线和线段的条数，
从而决定新增的区域数。试想在三维中则是否与平面的交线有关呢？当有n-1个平面时，
分割的空间数为f（n-1）。要有最多的空间数，则第n个平面需与前n-1个平面相交，
且不能有共同的交线。即最多有n-1 条交线。而这n-1条交线把第n个平面最多分割成
g（n-1）个区域。（g（n）为（1）中的直线分平面的个数）此平面将原有的空间一分
为二，则最多增加g（n-1）个空间。
```
        故：f=f(n-1)+g(n-1)    ps:g(n)=n(n+1)/2+1
                   =f(n-2)+g(n-2)+g(n-1)
                   ……
                  =f(1)+g(1)+g(2)+……+g(n-1)
                  =2+(1*2+2*3+3*4+……+(n-1)n)/2+（n-1）
                  =(1+2^2+3^2+4^2+……+n^2-1-2-3-……-n )/2+n+1
                  =(n^3+5n)/6+1
```

# HDU2045_LELE的RPG难题

题目大意： 有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.
解题思路： 首先可以推测出f(1)=3;f(2)=6;f(3)=6。由于f（n）首尾颜色不一样，所以f(n-1)有两种方案，第一种方案：f（n-1）首尾颜色不一样，在倒数第二的位置插入有f（n-1）种，第二种方案：首尾f（n-1）首尾颜色一致，所以必须在最后选一个不一样的颜色放进去有两种颜色可提供选择，方案数有2\*f（n-1）种
```
#include <iostream>
using namespace std;
const int MAX = 51;
int main(){
	long long f[MAX];
	f[1] = 3;
	f[2] = 6;
	f[3] = 6;//注意这个边界容易错，想象当n=1的时候其实是不满足f[n-2]的那种想法的
	for(int i = 4; i < MAX; i++){
		f[i] = f[i-1] + f[i-2] * 2;
	}
	int n;
	while(scanf("%d", &n) == 1)
		printf("%I64d\n", f[n]);
	return 0;
}
```
