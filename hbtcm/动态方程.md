# 状态转移方程

> `动态规划`中当前的状态往往依赖于前一阶段的状态和前一阶段的决策结果。例如我们知道了第i个阶段的状态Si以及决策Ui，那么第i+1阶段的状态Si+1也就确定了。所以解决动态规划问题的关键就是确定状态转移方程，一旦状态转移方程确定了，那么我们就可以根据方程式进行编码。

**在前面的文章`《动态规划-开篇》`讲到了如何设计一个动态规划算法，有以下四个步骤：

- 1、刻画一个最优解的结构特征。

- 2、递归地定义最优解的值。

- 3、计算最优解的值，通常采用自底向上的方法。

- 4、利用计算出的信息构造一个最优解。

对于确定状态转移方程就在第一步和第二步中，首先要确定问题的`决策对象`，接着对决策对象划分阶段并确定各个阶段的`状态变量`，最后建立各阶段的状态变量的`转移方程`。

  例如用dp[i]表示以序列中第i个数字结尾的最长递增子序列长度和最长公共子序列中用dp[i][j]表示的两个字符串中前 i、 j 个字符的最长公共子序列，我们就是通过对这两个数字量的不断求解最终得到答案的。这个数字量就被我们称为状态。状态是描述问题当前状况的一个数字量。首先，它是数字的，是可以被抽象出来保存在内存中的。其次，它可以完全的表示一个状态的特征，而不需要其他任何的辅助信息。最后，也是状态最重要的特点，状态间的转移完全依赖于各个状态本身，如最长递增子序列中，dp[x]的值由 dp[i](i < x)的值确定。若我们在分析动态规划问题的时候能够找到这样一个符合以上所有条件的状态，那么多半这个问题是可以被正确解出的。所以说，解动态规划问题的关键，就是寻找一个好的状态。
# 1. 最长公共字串（必须连续）
两个字符串str1和str2，长度分别为(s1,s2)
dp[i][j]表示以两个字符串分别以第i和第j个字符结尾所能达到的公共序列的长度，由于下面涉及到i-1,j-1,那么这个时候我们一般从i=1和j=1开始到i<=s1,j<=s2.
 ```  
for(int i=1;i<=s1;i++)///////////dp[i][j]=0(i=0或j=0)  
    for(int j=1;j<s2;j++)
        if(str[i-1]==str[j-1])  
            dp[i][j]=dp[i-1][j-1]+1;  
        else  
            dp[i][j]=0;  

```

# 2. 最长公共子序列（不要求连续）
根据最长公共子序列问题的性质，我们可以规定dp[i][j]为字符串1的前i个字符和字符串2的前j个字符的最长公共子序列的长度，由于下面涉及到i-1和j-1，那么这个时候我们一般从i=1和j=1开始到i<=s1,j<=s2.
```
ch1[i-1]==ch2[j-1],那么dp[i][j]=dp[i-1][j-1]+1;  
ch1[i-1]!=ch2[j-1]，那么我们知道ch1[i]和ch2[j]不可能在同一个公共子序列里出现，那么这个时候的最长的子序列可能以ch1[i]或ch2[i]结尾，那么由于  
dp[i][j]=max(dp[i-1][j],dp[i][j-1])  
故有  

for(int i=1;i<=s1;i++)////////////dp[i][j]=0(i=0或j=0)    
    for(int j=1;j<=s2;j++)  
        if(ch1[i-1]==ch2[j-1])  
            dp[i][j]=dp[i-1][j-1]+1;  
        else  
            dp[i][j]=max(dp[i-1][j],dp[i][j-]);  

```
# 3.最长上升或下降子序列
给定一个序列a1,a2.........an;
dp[i]表示以a[i]结尾的最长上升子序列长度(下降相反)
因为两者的思路都是一样的，所以只给出最长递增子序列的状态转移方程。假设有序列{a1,a2,...,an}，我们求其最长递增子序列长度。按照递推求解的思想，我们用F[i]代表若递增子序列以ai结束时它的最长长度。当 i 较小，我们容易直接得出其值，如 F[1] = 1。那么，如何由已经求得的 F[i]值推得后面的值呢？假设，F[1]到F[x-1]的值都已经确定，注意到，以ax 结尾的递增子序列，除了长度为1的情况，其它情况中，ax都是紧跟在一个由 ai(i < x)组成递增子序列之后。要求以ax结尾的最长递增子序列长度，我们依次比较 ax 与其之前所有的 ai(i < x)， 若ai小于 ax，则说明ax可以跟在以ai结尾的递增子序列之后，形成一个新的递 增子序列。又因为以ai结尾的递增子序列最长长度已经求得，那么在这种情况下，由以 ai 结尾的最长递增子序列再加上 ax 得到的新的序列，其长度也可以确定，取所有这些长度的最大值，我们即能得到 F[x]的值。特殊的，当没有ai(i < x)小 于ax， 那么以 ax 结尾的递增子序列最长长度为1。 即F[x] = max{1,F[i]+1|ai<ax && i<x}。
```
for（int i=1;i<=n;i++){  
    dp[i]=1;  
    for(k=1;k<i;k++){  
        if(a[k]<a[i]&&dp[i]<dp[k]+1)  
            dp[i]=dp[k]+1;  
      }  
}  
```

# 4.最大子序列的和问题
给定一个序列a1,a2,.......an;
求子序列的和最大问题dp[i]表示以a[i]结尾的子序列和，max为最大子序列和
思路：
1.如果输入的数据全为负数则最大值就是序列中最大数的值
2.如果有正数
```
for（int i=1;i<=n;i++）  {  
    dp[i]=dp[i-1]+a[i];  
    if(dp[i]<0)  
        dp[i]=0;  
    if(max<dp[i])  
        max=dp[i];  
}  

```
# 5.数塔问题
给定一个数组s[n][m]构成一个数塔求从最上面走到最底端经过的路径的和最大
我们采用自底向上的求解思路（注意从倒数第二行开始）
dp[i][j]表示走到第i行第j列的最大值
那么就有dp[i][j]=max{dp[i-1][j-1],dp[i-1]][j]}+s[i][j];
```
for(int i=n-1;i>=1;i--){  
    for(int j=1;j<=i;j++){  
         dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+s[i][j]  
    }  
} 
```
最后dp[s][s2]即为最大值


# 6. 01背包问题
有N件物品和一个容量为V的背包。第i件物品的体积是v[i],价值是c[i]。求解将那些物品装入背包可使价值总和最大
我们知道对于每一件物品我们有两种可能就是放与不放
dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值
dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]};   
这里我们从j=V倒推回来的话可以优化成
dp[j]=max(dp[j],dp[j-v[i]]+c[i]);
```
for(int i=1;i<=n;i++){  
   for(j=V;j>=0;j--){  
      if(j>=v[i])  
          dp[j]=max(dp[j],dp[j-v[i]]+c[i]);  
   }  
}  
```
dp[v] 即为最大的价值

[参考](http://www.voidcn.com/blog/mmc2015/article/p-6651408.html)<br>
[参考](http://www.cppblog.com/menjitianya/archive/2015/10/23/212084.html)
