# 1. 最长公共字串（必须连续）
两个字符串str1和str2，长度分别为(s1,s2)
dp[i][j]表示以两个字符串分别以第i和第j个字符结尾所能达到的公共序列的长度，由于下面涉及到i-1,j-1,那么这个时候我们一般从i=1和j=1开始到i<=s1,j<=s2.
 ```  
for(int i=1;i<=s1;i++)///////////dp[i][j]=0(i=0或j=0)  
    for(int j=1;j<s2;j++)
        if(str[i-1]==str[j-1])  
            dp[i][j]=dp[i-1][j-1]+1;  
        else  
            dp[i][j]=0;  

```

# 2. 最长公共子序列（不要求连续）
根据最长公共子序列问题的性质，我们可以规定dp[i][j]为字符串1的前i个字符和字符串2的前j个字符的最长公共子序列的长度，由于下面涉及到i-1和j-1，那么这个时候我们一般从i=1和j=1开始到i<=s1,j<=s2.
```
ch1[i-1]==ch2[j-1],那么dp[i][j]=dp[i-1][j-1]+1;  
ch1[i-1]!=ch2[j-1]，那么我们知道ch1[i]和ch2[j]不可能在同一个公共子序列里出现，那么这个时候的最长的子序列可能以ch1[i]或ch2[i]结尾，那么由于  
dp[i][j]=max(dp[i-1][j],dp[i][j-1])  
故有  

for(int i=1;i<=s1;i++)////////////dp[i][j]=0(i=0或j=0)    
    for(int j=1;j<=s2;j++)  
        if(ch1[i-1]==ch2[j-1])  
            dp[i][j]=dp[i-1][j-1]+1;  
        else  
            dp[i][j]=max(dp[i-1][j],dp[i][j-]);  

```
# 3.最长上升或下降子序列
给定一个序列a1,a2.........an;
dp[i]表示以a[i]结尾的最长上升子序列长度(下降相反)
```
for（int i=1;i<=n;i++){  
    dp[i]=1;  
    for(k=1;k<i;k++){  
        if(a[k]<a[i]&&dp[i]<dp[k]+1)  
            dp[i]=dp[k]+1;  
      }  
}  
```

# 4.最大子序列的和问题
给定一个序列a1,a2,.......an;
求子序列的和最大问题dp[i]表示以a[i]结尾的子序列和，max为最大子序列和
思路：
1.如果输入的数据全为负数则最大值就是序列中最大数的值
2.如果有正数
```
for（int i=1;i<=n;i++）  {  
    dp[i]=dp[i-1]+a[i];  
    if(dp[i]<0)  
        dp[i]=0;  
    if(max<dp[i])  
        max=dp[i];  
}  

```
5.数塔问题
给定一个数组s[n][m]构成一个数塔求从最上面走到最底端经过的路径的和最大
我们采用自底向上的求解思路（注意从倒数第二行开始）
dp[i][j]表示走到第i行第j列的最大值
那么就有dp[i][j]=max{dp[i-1][j-1],dp[i-1]][j]}+s[i][j];
```
for(int i=n-1;i>=1;i--){  
    for(int j=1;j<=i;j++){  
         dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+s[i][j]  
    }  
} 
```
最后dp[s][s2]即为最大值


6. 01背包问题
有N件物品和一个容量为V的背包。第i件物品的体积是v[i],价值是c[i]。求解将那些物品装入背包可使价值总和最大
我们知道对于每一件物品我们有两种可能就是放与不放
dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值
dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]};   
这里我们从j=V倒推回来的话可以优化成
dp[j]=max(dp[j],dp[j-v[i]]+c[i]);
```
for(int i=1;i<=n;i++){  
   for(j=V;j>=0;j--){  
      if(j>=v[i])  
          dp[j]=max(dp[j],dp[j-v[i]]+c[i]);  
   }  
}  
```
dp[v] 即为最大的价值
